# 什么是 shell？

- shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序
- 用户可以用 Shell 来启动、挂起、停止或者编写一些程序
- Shell 还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。
- Shell 是解释执行的脚本语言，在 Shell 中可以直接调用 Linux 系统命令。

## 1. 基本用法

### 1.1 echo

- 输出命令
- `-e` 激活转译字符

```bash
echo -e 'h\tello'
```

### 1.2 编写执行 shell

编写文件，开头需要`#!/bin/bash`，代表是 shell 脚本

```bash
vi 1.sh
#!/bin/bash
echo hello
:wq

#执行shell文件
sh 1.sh
#或者
chmod u+x 1.sh
./1.sh
```

### 1.3 别名

- 命令别名就是小名
- 临时生效 `alias cp="cp -i"`
- 写入环境变量配置文件 `vi ~/.bashrc`
- `source ~/.bashrc`
- 删除别名 `unalias 别名`

### 1.4 命令的生效顺序

- 绝对路径或者相对路径
- 别名
- bash 内部命令
- 按照\$PATH 环境变量定义的目录查找顺序找到的第一个命令

### 1.5 命令快捷键

| 命令   | 概念                       |
| ------ | -------------------------- |
| ctrl+c | 强制终止当前命令           |
| ctrl+l | 清屏                       |
| ctrl+a | 光标移动到命令行首         |
| ctrl+e | 光标移动到命令行尾         |
| ctrl+u | 从光标所在的位置删除到行首 |

### 1.6 历史命令

```bash
#查询history
history
#清空历史
history -c
#写入历史文件~/.bash_history，一般是退出时会自动写入到文件中
history -w
#vi修改
vi /etc/profile
HISSIZE=10000
```

- history [选项][历史命令保存文件]
- 选项
  - -c 清空历史命令
  - -w 把缓存中的历史命令写入历史命令保存文件 ~/.bash_history
- 默认保存 1000 条 `/etc/profile` `HISSIZE=10000`

### 1.7 调用历史命令

- 使用上下箭头调用以前的历史命令
- 使用 !n 重复执行第 n 条历史命令
- 使用 !! 重复执行上一条命令
- 使用 !字符 重复执行最后一条以该字符串开头的命令

```bash
!3
!!
!his
```

### 1.8 输出重定向

#### 1.8.1 标准输出设备

| 设备   | 设备文件    | 文件描述符 | 类型         |
| ------ | ----------- | ---------- | ------------ |
| 键盘   | /dev/stdin  | 0          | 标准输入     |
| 显示器 | /dev/stdout | 1          | 标准输出     |
| 显示器 | /dev/stderr | 2          | 标准错误输出 |

| 类型                       | 符号                  | 作用                                                               |
| -------------------------- | --------------------- | ------------------------------------------------------------------ |
| 标准输出重定向             | 命令 > 文件           | 以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中           |
| 标准输出重定向             | 命令 >> 文件          | 以追加的方式，把命令的正确输出输出到指定的文件或设备当中           |
| 错误输出重定向             | 命令>文件             | 以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中           |
| 错误输出重定向             | 命令>>文件            | 以追加的方式，把命令的错误输出输出到指定的文件或设备当中           |
| 正确输出和错误输出同时保存 | 命令>文件 2>&1        | 以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中           |
| 正确输出和错误输出同时保存 | 命令>文件 2>>&1       | 以追加的方式，把正确输出和错误输出都保存到同一个文件当中           |
| 正确输出和错误输出同时保存 | 命令&>文件            | 以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中           |
| 正确输出和错误输出同时保存 | 命令&>>文件           | 以追加的方式，把正确输出和错误输出都保存到同一个文件当中           |
| 正确输出和错误输出同时保存 | 命令>>文件 1 2>文件 2 | 以覆盖的方式，正确的输出追加到文件 1 中，把错误输出追加到文件 2 中 |

```bash
#覆盖的方式 输出到文件中
echo 你好 > hello.txt
cat hello.txt
echo 你也好 > hello.txt
cat hello.txt

#追加的方式输入到文件
echo 你好 > hello.txt
cat hello.txt
echo 你也好 >> hello.txt
cat hello.txt

#覆盖输出错误质量到文件
ls aa > error.txt 2>&1
cat error.txt

#追加输出错误质量到文件
ls bb >> error.txt 2>&1
ls bb >> error.txt 2>&1
cat error.txt


```

#### 1.8.2 输入重定向

- `wc` 命令的功能为统计指定文件中的行数、字数、字节数, 并将统计结果显示输出
- 命令 `<` 文件把文件做为命令的输入
- 命令 `<<` 标识符 标识符把标识符之间内容作为命令的输入

```bash
wc < error.txt
#3  27 150
wc << !
hello
world
!
#2  2 12
```

### 1.9 管道符号

#### 1.9.1 多命令顺序执行

Js 玩家大喜，很好李姐。
| 多命令执行符 | 格式 | 作用 | 案例 |
| ------------ | --------------- | ---------------------------------------------------------------------------------- | ----------------- |
| ; | 命令 1;命令 2 | 多个命令执行，命令之间没有任何逻辑联系 | echo 1;echo 2; |
| && | 命令 1&&命令 2 | 逻辑与 当命令 1 正确执行，则命令 2 才会执行 当命令 1 执行不正确，则命令 2 不会执行 | echo 1&&echo 2; |
| `||` | `命令1|| 命令2` | 逻辑或 当命令 1 执行不正确，则命令 2 才会执行 当命令 1 正确执行，则命令 2 不会执行 | `echo 1||echo 2;` |

```bash
#利用;一行执行多个命令
echo 1;echo 2;
#&&前面命令错误，后面命令不执行
ls xx&&echo 2
#或命令，前面失败，后面命令继续执行
ls xx || echo 2
```

#### 1.9.2 管道符号

- 命令 1 的正确输出会作为命令 2 的操作对象
- 命令 1|命令 2

```bash
#命令1结果是命令2参数
ls /etc/ | more
```

#### 1.9.3 通配符

匹配文件名和目录名

| 通配符 | 作用                                        |
| ------ | ------------------------------------------- |
| ?      | 匹配一个任意字符                            |
| \*     | 匹配 0 个或任意字符，也就是可以匹配任意内容 |
| []     | 匹配中括号中任意一个字符                    |
| [-]    | 匹配中括号中任意一个字符,-代表范围          |
| [^]    | 匹配不是中括号中的一个字符                  |

```bash
#和正则相似
[1-10]
```

#### 1.9.4 其他

| 符号                            | 作用                                                                                             |
| ------------------------------- | ------------------------------------------------------------------------------------------------ |
| ''                              | 单引号。在单引号中所有的特殊符号，如\$和`都没有特殊含义                                          |
| ""                              | 双引号，在双引号里特殊符号都没有特殊含义，但是 \$ ` \ 例外，拥有调用变量值，引用命令和转义的含义 |
| `` | 反引号，扩起来的是系统命令 |
| \$()                            | 和反引号一样                                                                                     |
| #                               | 在 shell 脚本中，#开头的行代表注释                                                               |
| \$                              | 用于调用变量的值                                                                                 |
| \                               | 转义符号                                                                                         |

## 2. 变量

### 2.1 变量的概念

- 可以变化的量
- 变量必须以字母或下划线开头，名字中间只能由字母，数字和下划线组成
- 变量名的长度不得超过 255 个字符
- 变量名在有效范围内必须唯一
- 变量默认类型都是字符串

### 2.2 变量的分类

- 字符串
- 整型
- 浮点型
- 日期型

### 2.3 自定义变量

- 这些变量的值是自己定义的
- 变量名不能为数字开头
- 等号左右两边不能有空格

#### 2.3.1 定义、输出变量

```bash
#定义变量
name="bob"
age=18

#输出变量
echo $name #bob
echo $age #18

#默认值都是字符串
a=1
b=2
c=3
d=$a+$b+$c
echo d #1+2+3

#赋值时应用变量
b="$b"2 #22
b=${b}2 #222
```

#### 2.3.2 set

- 可以理解为 get。查询系统中默认所有已经生效的变量，包括系统变量,也包括自定义变量

```bash
set | grep name
```

#### 2.3.3 unset

- 删除变量

```bash
#name变量被删除
unset name
```

### 2.4 环境变量

- 环境变量是全局变量，而自定义变量是局部变量
- 自定义变量会在当前的 shell 中生效，其他窗口的 shell 不能访问，而环境变量会在当前 shell 以及其子 shell 中生效。
- 这种变量主要保存的是和系统操作环境相关的数据
- 变量可以自定义，但是对系统生效的环境变量名和变量作用是固定的

#### 2.4.1 自定义环境变量

`export 变量名=变量值`

```bash
export env_name=prod
#bash命令输入子shell，也可以拿到环境变量
echo env_name
```

#### 2.4.2 env

- 仅仅用来查看环境变量，而不看到本地变量

```bash
env
```

#### 2.4.3 常用环境变量

| 变量名     | 含义                                                   | 示例                              |
| ---------- | ------------------------------------------------------ | --------------------------------- |
| HOSTNAME   | 主机名                                                 | HOSTNAME=localhost                |
| SHELL      | 当前的 shell                                           | SHELL=/bin/bash                   |
| TERM       | 终端环境                                               | TERM=xterm                        |
| HISTSIZE   | 历史命令条数                                           | HISTSIZE=1000                     |
| SSH_CLIENT | 当前操作环境如果是用 SSH 连接的话，这里会记录客户端 IP | SSH_CLIENT=192.168.1.100 57596 22 |
| SSH_TTY    | SSH 连接的终端                                         | SSH_TTY=/dev/pts/1                |
| USER       | 当前登录的用户                                         | USER=root                         |

#### 2.4.4 path

- 系统搜索路径
  `#!/bin/bash`linux 不识别文件类型，文件后缀只是给人看，所以文件中以注释的方式，按照!后问方式执行文件

```bash
# echo $PATH
/usr/lib/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
```

如果想把一个自定义的脚本直接可以执行，或者把这个文件拷贝到目标目录下，或者把脚本所在目录添加到环境变量中的 PATH 路径中
创建 hello.sh

```bash
vi hello.sh

#!/bin/bash
echo hello
./hello.sh

#把myshell加入环境变量
/root/myshell/hello.sh
export PATH="$PATH":/root/myshell   #临时生效
hello.sh
```

#### 2.4.5 语系环境变量

- 查询当前系统语系
- 在 Linux 中通过 locale 来设置程序运行的不同语言环境，locale 由 ANSI C 提供支持。locale 的命名规则为<语言>\_<地区>.<字符集编码>，如 zh_CN.UTF-8，zh 代表中文，CN 代表大陆地区，UTF-8 表示字符集。
- LANG: 定义系统主语系的变量

```bash
#查询当前
locale
LANG=zh_CN.UTF-8

echo $LANG

#下次开机之后我们系统环境
cat /etc/sysconfig/i18n
```

#### 2.4.6 中文支持

- 图形界面可以支持中文
- 第三方工具比如 xshell 语系设置正确可以支持中文
- 虚拟机中的纯字符界面不支持中文

### 2.5 位置参数变量

- 这种变量主要是用来向脚本当中传递参数或数据的,变量名不能自定义,变量作用是固定的

| 位置参数变量 | 作用                                                                                    |
| ------------ | --------------------------------------------------------------------------------------- |
| \$n          | n 为数字，$0代表命令本身，$1-$9代表第1到第9个参数，10以上的参数需要用大括号包含,如${10} |
| \$\*         | 这个变量代表命令中所有的参数，\$\*把所有的变看数看成一个整体                            |
| \$@          | 这个变量也代表命令行中所有的参数，不过\$@把每个参数进行区分                             |
| \$#          | 这个变量代表命令行中所有参数的个数                                                      |

1. \$n 演示 创建 sum.sh

```bash
#!/bin/bash
num1=$1
num2=$2
sum=$((num1+num2))
echo $sum

:wq
sh sum.sh 1 2
```

2. \$\*演示 创建 for1.sh

```bash
#!/bin/bash
for i in "$*"
do
  echo "i=$i"
done

:wq
sh for1.sh 1 2 3
```

3. \$@演示 创建 for2.sh

```bash
#!/bin/bash
for i in "$@"
do
  echo "i=$i"
done

:wq
sh for2.sh 1 2 3
```

4. \$#演示 创建 for3.sh

```bash
#!/bin/bash
echo "$#"
```

### 2.6 预定义变量

- 是脚本中已经定义好的变量，变量名不能自定义，变量作用也是固定的

| 位置参数变量 | 作用                                                              |
| ------------ | ----------------------------------------------------------------- |
| \$?          | 最后一次执行的命令的返回状态。0 表示正确执行，非 0 表示不正确执行 |
| \$\$         | 当前进程的进程号(PID)                                             |
| \$!          | 后台运行的最后一个进程号(PID)                                     |

```bash
echo $?
echo $$
echo $!
```

### 2.7 read

- read [选项][变量名]

| 选项 | 含义                                                          |
| ---- | ------------------------------------------------------------- |
| -p   | 提示信息，在等待 read 输入时，输出提示信息                    |
| -t   | 秒数: read 命令会一直等待用户输入，使用此选项可以指定等待时间 |
| -n   | 字符数，read 命令只接受指定的字符数，就会执行                 |
| -s   | 隐藏输入的数据，适用于机密信息的输入                          |

创建 read.sh

```bash
#!/bin/bash
read -p "请输入用户名" -t 5 name
echo -e "\n"
read -p "请输入性别[男/女]" -n 1 gender
echo -e "\n"
read -p "请输入密码" -s password
echo -e "\n"
echo $name,$gender,$password

:wq
sh read.sh
```

## 3. 运算符

在 shell 里，变量是弱类型并且默认是字符串类型(根据值确定类型)

### 3.1 declare 命令

- 用来声明变量类型
- declare [+/-][选项] 变量名

| 选项 | 含义                        |
| ---- | --------------------------- |
| -    | 给变量设定类型属性          |
| +    | 取消变量的类型属性          |
| -a   | 将变量声明为数组类型        |
| -i   | 将变量声明为整数型(integer) |
| -x   | 将变量声明为环境变量        |
| -r   | 将变量声明为只读变量        |
| -p   | 显示指定变量的被声明的类型  |

1. 变量类型

```bash
# 默认为字符串类型
a=1
b=2
c=$a+$bz
echo c # 1+2

#定义为int类型
declare -i c=$a+$b
echo c #3

#取消int类型
declare +i c
c=$a+$b
echo c

#显示变量的类型
declare -i c
c=$a+$b
declare -p c # declare -i c="3"

#声明为环境变量
declare -x aa=1
set | grep aa

#声明为制度
declare -r c
c=1 # c: readonly variable
```

2. 数组

```bash
# 声明为数组类型
# 如果是一个整体就需要加{}，要不然打印$list[1]，就会输出1[0]
declare -a list
list[0]=1
list[1]=2
# 默认只会打印第一个元素
echo ${list} # 1
# 打印第二个元素
echo ${list[1]} # 2
#打印全部
echo ${list[*]} # 1 2
```

3. 声明环境变量

- `export` 最终执行的是 `declare -x` 命令
- `declare -p` 可以查看所有的类型

```bash
export NAME=bob
declare -x NAME=bob
```

4. 数值运算的方法

- 只要用 declare 声明变量的时候指定类型就可以进行数值运算
- expr 或 let

号左右两侧必须有空格,否则还是整块输出

```bash
#num1=2
#num2=3
#s=$(expr $num1 + $num2)
#echo $s
5

#s=$(($num1+$num2))
#echo $s
5
#s=$[$num1+$num2]
#echo $s
5

d=$(date)
echo $d
```

## 4.环境变量配置文件

### 4.1 source 命令

- 修改完配置文件后，必须注销重新登录才能生效，使用 source 命令可以不用重新登录
- source 配置文件
- . 配置文件

### 4.2 环境变量配置文件简介

- PATH、HISTSIZE、PS1、HOSTNAME 等环境变量写入对应的环境变量配置文件
- 环境变量配置文件中主要是定义地系统操作环境生效的系统默认环境变量，如 PATH 等 此下文件登录时起作用的环境变量

| 路径                 | 说明               |
| -------------------- | ------------------ |
| /etc/profile         | 系统变量           |
| /etc/profile.d/\*.sh | 系统变量           |
| /etc/bashrc          | 系统变量           |
| ~/.bash_profile      | 只会对当前用户生效 |
| ~/.bashrc            | 只会对当前用户生效 |

### 4.3 环境变量配置文件的功能

#### 4.3.1 /etc/profile

在这里修改系统变量

```bash
cat  /etc/profile | grep USER
```

| 变量名  | 含义     |
| ------- | -------- |
| USER    | 用户名   |
| LOGNAME | 登录名   |
| MAIL    | 邮箱地址 |
| PATH    | 查找路径 |
| HOSTNAE | 主机名   |
| umask   | 权限掩码 |

#### 4.3.2 ~/.bash_profile

- PATH 在这里修改 PATH 路径
- 调用 ~/.bashrc

#### 4.3.3 ~/.bashrc

- 配置 alias 改别名在这里
- 调用 /etc/bashrc

#### 4.3.4 /etc/bashrc

- PS1 登录提示符在这里修改
- umask
- PATH 变量
- 调用 /etc/profile.d/星.sh 文件

#### 4.3.5 其它配置文件

##### 4.3.5.1 注销时生效的环境变量配置文件

~/.bash_logout

##### 4.3.5.2 脚本历史

当正确退出计算机的时候会历史记录会写入文件 ~/.bash_history

##### 4.3.5.3 Shell 登录信息

本地终端欢迎信息 /etc/issue 远程终端欢迎信息 /etc/issue.net 不管远程还是本地都可以生效 /etc/motd

| 参数 | 含义                         |
| ---- | ---------------------------- |
| \d   | 当前系统日期                 |
| \s   | 显示操作系统名称             |
| \l   | 显示登录的终端号             |
| \m   | 显示硬件体系结构，如 i386 等 |
| \n   | 显示主机名                   |
| \o   | 显示域名                     |
| \r   | 显示内核版本                 |
| \t   | 显示当前系统时间             |
| \u   | 显示当前登录用户的序列号     |

## 5. 正则表达式

### 5.1 概念

- 正则表达式是用于描述字符排列和匹配模式的一种语法规则
- 它主要用于字符串的模式分割、匹配查找及替换操作

### 5.2 通配符

- 通配符用来匹配符合条件的文件名，通配符是完全匹配。
- ls find 这些命令不支持正则，只能使用通配符

| 符号 | 含义                         |
| ---- | ---------------------------- |
| ?    | 匹配任意一个字符             |
| \*   | 匹配任意多个字符             |
| []   | 匹配中括号中范围内的一个字符 |

### 5.3 正则表达式

- 正则表达式是用来在文件中匹配符合条件的字符串，是包含匹配。
- grep awk sed 等都可以支持正则表达式

### 5.4 元字符

`alias grep='grep --color=auto'`

| 元字符 | 作用                                                                                                                                                              | 示例                  |
| ------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------- |
| \*     | 前一个字符匹配 0 次或任意多次                                                                                                                                     | grep 1\* reg.txt      |
| .      | 匹配除换行符外的任意一个字符                                                                                                                                      | grep . reg.txt        |
| ^      | 匹配行首。例如，^hello 会匹配以 hello 开头的行                                                                                                                    | grep ^a reg.txt       |
| \$     | 匹配行尾。例如，hello& 会匹配以 hello 结尾的行                                                                                                                    | grep a\$ reg.txt      |
| []     | 匹配屮柄号屮指定的任意一个字符，而且只匹配一个字符。 例如.[aoeiu]匹配任意一个元音字母， [0-9] 匹配任意一位数字，[a-z][0-9] 匹配由小写字母和一位数字构成的两位字符 | grep ab[bc]c reg.txt  |
| [^]    | 匹配除中括号中的字符以外的任意一个字符。例如，[^0-9] 匹配任意一位非数字字符，[^a-z] 匹配任意一位非小写字母                                                        | grep a[^fg]c reg.txt  |
| \\     | 转义符，用于取消特殊符号的含义                                                                                                                                    | grep \\.\$ reg.txt    |
| {n}    | 表示其前面的字符恰好出现 n 次。例如，[0-9]{4} 匹配 4 位数字，[1][3-8][0-9]{9} 匹配手机号码                                                                        | grep "a{1}" reg.txt   |
| (n,}   | 表示其前面的字符出现不少于 n 次。例如，[0-9]{2,} 匹配两位及以上的数字                                                                                             | grep "a{1,}" reg.txt  |
| {n,m}  | 表示其前面的字符至少出现 n 次，最多出现 m 次。例如，[a-z]{6,8} 匹配 6〜8 位的小写字母                                                                             | grep "a{2,3}" reg.txt |

### 5.5 cut

- cut 用来提取文本中的某一部分文本
- cut [选项] 文件名
  - -f 列号，用来指定要提取的列
  - -d 分隔符，按照指定分隔符分割列,默认分隔符是 TAB 制表符

```bash
cat /etc/passwd
#用:分割，查询第1，7列
cat /etc/passwd -d : -f 1,7
#显示当前系统上磁盘文件系统磁盘使用情况(disk free)
df -h
df -h | grep /dev/sda1 | cut -f 5
```

### 5.6 printf

- 按规定格式输出
- printf 输出类型，输出内容

| 参数  | 含义                                                                                              |
| ----- | ------------------------------------------------------------------------------------------------- |
| %ns   | 输出字符串,n 是数字指代输出几个字符                                                               |
| %ni   | 输出整数,n 是指输出几个数字                                                                       |
| %m.nf | 输出浮点数,m 和 n 是数字，指代输出的整数位数和小数位数，如%6.2f 代表输出 6 位，2 位小数，4 位整数 |

```bash
#格式化显示每列之间的空格(t%s)
printf "%s\t%s\t%s\t%s\t%s\t%s\n" $(df -h | grep /dev/sda1)
```

### 5.7 awk

- awk '条件 1{动作 1} 条件 2{动作 2}...' 文件名

- 条件(Pattern)

  - 一般使用关系表达式作为条件
  - x > 10 判断变量 x 是否大于 10
  - x >=10 大于等于
  - x <=10 小于等于

- 动作(Action)

- 格式化输出
  - $0 整行 $1 第一列...

```bash
# 打印sda1中1-6
df -h | grep sda1 | awk 'print {$1,$6}'
```

#### 5.7.1 begin end

- awk 可以正确截取制表符和空格
- begin 在所有的输出之前打印
- end 在所有的输出之后打印

```bash
# 开始-结束打印
vi numbers.txt
i
1 2 3
:wq

awk 'BEGIN {print "开始"} END {print "结束"}' numbers.txt
```

#### 5.7.2 FS

- Field Separator，字段分隔符

```bash
#打印每一行的第一列 第二列   \t空格
awk 'BEGIN{FS=":"}{print $1"\t"$2}' /etc/passwd
```

#### 5.7.3 声明变量

```bash
#还可以打印计算numbers中每一列值的和
awk 'BEGIN {sum=0} {sum=sum+$1} END {print sum}' numbers.txt
```

#### 5.7.4 多条件

```bash
vi score.txt
i
张三 80
李四 90
王五 70

awk '$2>=90 {print $1"\t优"} $2>=80 {print $1"\t良"} $2<80 {print $1"\t一般"}' score.txt
```

#### 5.7.5 NR

- NR,表示 awk 开始执行程序后所读取的数据行数

```bash
#$0显示整行
awk 'print NR,$0' score.txt
```

#### 5.7.6 OFS

- OFS Out of Field Separator，输出字段分隔符

```bash
vi hello.txt
你好吗，我很好
:wq

awk 'BEGIN {FS="，";OFS=">"} END {print $1,$2,$3}' hello.txt
```

### 5.8 sed 命令

- sed 是一个轻量级编辑器，主要用来对数据进行选取、替换、替换和新增操作
- 不会修改源文件，只会把修改内容打印，要修改的话选项加 -i
- sed [选项] '[动作]' 文件名
- 所有的动作都必须用单号号括起来
- 类型类似于批量 vi 操作

- 选项
  | 参数 | 含义 | 实例 |
  | ---- | --------------------------------------------------------------------------------------- | -------------------------------------- |
  | -n | 一般 sed 命令会把所有的数据都输出到屏幕上，如果加入此选项则只会把处理过的行输出到屏幕上 | sed -n '2p' score.txt |
  | -e | 允许对输入数据应用多条 sed 编辑命令 用;号分割 | sed -e 's/75/70/g;s/55/50/g' score.txt |
  | -i | 用 sed 的修改直接修改编辑的文件，而不是在屏幕上输出 | sed -i '1i newline' score.txt |

- 动作
  | 参数 | 含义 | 示例 |
  | ---- | ------------------------------------------ | -------------------------- |
  | a | 追加，在每一行或者指定行下面添加一行或多行 | sed '1a newline' score.txt |
  |c| 行替换，用 c 后面的字符串替换掉原始整个数据行 |sed 'c newline' score.txt|
  |s |字符串替换,用一个字符串替换另外一个字符串，格式为 "行范围 s/旧字符串/新字符串/g"| sed '3s/lisi/lisisi/g' score.txt|
  |i| 插入，在当前行插入一行或多行| sed '1i newline' score.txt|
  |d| 删除指定的行 |sed '1,2d' score.txt|
  |p |打印,输出指定的行 |sed -n '2p' score.txt|

```bash
vi sed.txt
aaa
bbb
ccc
ddd

#在第二行插入
sed '2i newline' sed.txt
#替换行
sed '1c 111' sed.txt
#替换第一行所有a字母 如果只替换一个 `1s/a/A/2`
sed '1s/a/A/g' sed.txt
#从第二行删除到第二行
sed '2,2d' sed.txt
#打印第二行
sed '2p' sed.txt
```

### 5.9 排序命令 sort

- sort [选项] 文件名
- 选项
  |选项|含义|示例|
  |---|---|---|
  |-f| 忽略大小写 |sort -f -t ":" -n -k 5,5 /etc/passwd|
  |-n |以数值型进行排序，默认使用字符串顺序| sort -t ":" -n -k 3,3 /etc/passwd|
  |-r |反向排序，默认从小到大| sort -r /etc/passwd|
  |-t |指定分割符，默认分割符是制表符| sort -t ":" -k 3,3 /etc/passwd|
  |-k n[,m]|按照指定的字段范围排序。从第 n 个字段开始，到第 m 个字段结束，默认是到行尾| sort -t ":" -k 3,3 /etc/passwd|

```bash
sort -r sed.txt
```

### 5.10 wc

- wc [选项] 文件名

| 选项 | 含义         |
| ---- | ------------ |
| -l   | 只统计行数   |
| -w   | 只允许单词数 |
| -m   | 只统计字符数 |

```bash
cat -l sed.txt
```

## 6. 流程控制

### 6.1 条件判断

#### 6.1.1 按照文件类型进行判断

| 选项 | 含义                           |
| ---- | ------------------------------ |
| -d   | 文件是否存在并且是目录         |
| -e   | 文件是否存在                   |
| -f   | 文件是否存在并且是普通文件     |
| -b   | 文件是否存在并且是块设备文件   |
| -c   | 文件是否存在并且是字符设备文件 |
| -L   | 文件是否存在并且是链接文件     |
| -p   | 文件是否存在并且是管道文件     |
| -s   | 文件是否存在并且是否为非空     |
| -S   | 文件是否存在并且是套接字文件   |

```bash
#判断某个文件是否存在
test -e hello.txt
echo $?

[ -e sed.txt ] &&  echo '存在' || echo '不存在'

#exist.sh
vi exist.sh
#!/bin/bash
[ -e hello.txt ] && echo '存在' || echo '不存在'
[ -e sed.txt ] &&  echo '存在' || echo '不存在'
:wq

sh exist.sh
```

#### 6.1.2 按照文件权限进行判断

| 选项 | 含义                               |
| ---- | ---------------------------------- |
| -r   | 文件是否存在，并且是否拥有读权限   |
| -w   | 文件是否存在，并且是否拥有写权限   |
| -x   | 文件是否存在，并且是否拥有执行权限 |

```bash
test -r sed.txt
echo $?
```

#### 6.1.3 两个文件间的比较

| 选项              | 含义                                                     |
| ----------------- | -------------------------------------------------------- |
| 文件 1 -nt 文件 2 | 判断文件 1 的修改时间是否比文件 2 的新                   |
| 文件 1 -ot 文件 2 | 判断文件 1 的修改时间是否比文件 2 的旧                   |
| 文件 1 -ef 文件 2 | 判断文件 1 和文件 2 的 inode 号是否一致,可用于判断硬链接 |

```bash
[ numbers.txt -nt score.txt ] && echo '新' || echo '旧'
```

#### 6.1.4 两个整数间的比较

| 选项              | 含义                           |
| ----------------- | ------------------------------ |
| 整数 1 -eq 整数 2 | 判断整数 1 是否和整数 2 相等   |
| 整数 1 -ne 整数 2 | 判断整数 1 是否和整数 2 不相等 |
| 整数 1 -gt 整数 2 | 判断整数 1 是否大于整数 2      |
| 整数 1 -lt 整数 2 | 判断整数 1 是否小于整数 2      |
| 整数 1 -ge 整数 2 | 判断整数 1 是否大于等于整数 2  |
| 整数 1 -le 整数 2 | 判断整数 1 是否小于等于整数 2  |

```bash
num1=1
num2=2
[ $num1 -eq $num2 ] && echo '相等' || echo '不相等'
```

#### 6.1.5 字符串的判断

| 选项                 | 含义                               |
| -------------------- | ---------------------------------- |
| -z 字符串            | 判断字否串是否为空                 |
| -n 字符中            | 判断字符串是否为非空               |
| 字符串 1 == 字符串 2 | 判断字符串 1 是否和字符串 2 相等   |
| 字符串 1 != 字符串 2 | 判断字符串 1 是否和字符串 2 不相等 |

```bash
name1=a
name2=b
[ -z $name ] && echo '为空' || echo '不为空'
[ $name1 == $name2 ] && echo '相等' || echo '不相等'
```

#### 6.1.6 多重条件判断

| 选项             | 含义   |
| ---------------- | ------ |
| 判断 1 -a 判断 2 | 逻辑与 |
| 判断 1 -o 判断 2 | 逻辑或 |
| !判断            | 逻辑非 |

```bash
#1>2||3<4
[ 1 -gt 2 -o 3 -lt 4 ] && echo y || echo n
```

### 6.2 单分支 if 语句

- if 语句使用 fi 结尾
- [条件判断式]就是使用 test 命令进行判断，所以中括号和条件判断式之间必须有空格
- then 后面跟符合条件之后执行的程序，可以放在[]之后，用;分隔，也可以换行，不用;

#### 6.2.1 语法

```bash
if [条件判断];then
 代码体
fi

if [条件判断]
then
 代码体
fi

if [ 2 -ne 4 ];then echo small;fi
```

#### 6.2.2 判断当前用户是否是 root 用户

```bash
vi isRoot.sh

#!/bin/bash
user=`whoami`
if [ "$user" == root ]
then
        echo 我是管理员
#else
#        echo 我不是管理员
fi
:wq

sh isRoot.sh
```

### 6.3 双分支 if 语句

#### 6.3.1 语法

```bash
if [条件判断]
then
 代码体1
else
 代码体2
fi
```

#### 6.3.2 判断是否目录

```bash
vi isDir.sh

#!/bin/bash
#读一个值赋给变量dir
read -t 10 -p "please input a filename" dir
if [ -d "$dir" ]
then
echo is dir
else
echo not dir
fi
```

### 6.4 case 语句

- case 和 if 都是多分支判断语句,if 能判断多个条件,case 只能判断一个条件

#### 6.4.1 语法

```bash
case 变量名 in
值1)
  代码块1
  ;;
值2)
  代码块2
 ;;
*)
  代码块3
 ;;
esac
```
